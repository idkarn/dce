# Copyright (c) 2022 Mike Redko
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
import configparser, glob, re, sys, os, shlex
from typing import Literal, Optional

def error(msg: str):
  if sys.stderr.isatty():
    sys.stderr.write("\x1b[31m")
  
  sys.stderr.write("error: " + str(msg))

  if sys.stderr.isatty():
    sys.stderr.write("\x1b[m")
  
  sys.stderr.write("\n")

def get_platform_name() -> str:
  if sys.platform == "darwin": return "macos"
  if sys.platform == "linux": return "linux"
  if sys.platform == "msys": return "msys"

def save_ninja(fname: str, lines: list[str]):
  with open(fname + ".ninja", "w") as f:
    f.write(f"# generated by gen.py from {fname}\n")
    f.write('\n'.join(lines))

class CmdType(Enum):
  ONE_TO_ONE = 0
  MANY_TO_ONE = 1
  ONE_TO_MANY = 2

CMD_TYPE_STRING = {
  "121": CmdType.ONE_TO_ONE,
  "one to one": CmdType.ONE_TO_ONE,
  "one2one": CmdType.ONE_TO_ONE,
  "one-one": CmdType.ONE_TO_ONE,
  "one->one": CmdType.ONE_TO_ONE,
  "m21": CmdType.MANY_TO_ONE,
  "many to one": CmdType.MANY_TO_ONE,
  "many2one": CmdType.MANY_TO_ONE,
  "many-one": CmdType.MANY_TO_ONE,
  "many->one": CmdType.MANY_TO_ONE,
  "12m": CmdType.ONE_TO_MANY,
  "one to many": CmdType.ONE_TO_MANY,
  "one2many": CmdType.ONE_TO_MANY,
  "one-many": CmdType.ONE_TO_MANY,
  "one->many": CmdType.ONE_TO_MANY,
}

@dataclass
class CmdCfg:
  typ: CmdType
  cmd: str
  inp: str
  out: str

@dataclass
class CmdInfo:
  name: str
  vars: dict[str, str]

@dataclass
class ProjectCfg:
  name: str
  desc: str
  deps: list[str]
  srcs: list[str]
  cmds: list[CmdInfo]
  expt: list[str]

@dataclass
class Translation:
  lines: list[str]
  includes: list[tuple[bool, str]]
  outputs: list[str]

class CfgFile:
  def translate(self) -> Translation:
    raise NotImplementedError

@dataclass
class CommandsCfgFile(CfgFile):
  cmds: dict[str, CmdCfg]

  def translate(self) -> Translation:
    l: list[str] = []
    for name, cfg in self.cmds.items():
      l.append(f"rule {name}")
      l.append(f"  command = {cfg.cmd}")
      l.append("")
    return Translation(lines = l, includes = [], outputs = [])

@dataclass
class ProjectCfgFile(CfgFile):
  cfg: ProjectCfg
  vars: dict[str, str]
  includes: dict[str, CfgFile]

  def translate(self) -> Translation:
    l: list[str] = []
    includes: list[tuple[bool, str]] = []

    cmds: dict[str, CmdCfg] = {}

    external_ins = []
    for path in self.cfg.deps:
      parsed = parse_cfg(path)
      if parsed is None: continue
      dep = parsed.translate()
      save_ninja(path, dep.lines)
      includes += dep.includes
      includes.append((True, f"{path}.ninja"))
      external_ins += dep.outputs

    for path, file in self.includes.items():
      includes.append((False, f"{path}.ninja"))
      save_ninja(path, file.translate().lines)
      if isinstance(file, CommandsCfgFile):
        for k, v in file.cmds.items():
          cmds[k] = v
    
    l.append("")

    for name, value in self.vars.items():
      l.append(f"{name} = {value}")
    
    l.append("")

    src = [file for path in self.cfg.srcs for file in glob.glob(path)]
    src += external_ins
    outs = []

    for cmd in self.cfg.cmds:
      inp_pat = re.compile(cmds[cmd.name].inp)
      inp_src = []
      for file in src:
        if inp_pat.fullmatch(file): inp_src.append(file)
      if cmds[cmd.name].typ == CmdType.ONE_TO_ONE:
        out_src = [inp_pat.sub(cmds[cmd.name].out, file) for file in inp_src]
        for inp_file, out_file in zip(inp_src, out_src):
          l.append(f"build {out_file}: {cmd.name} {inp_file}")
          outs.append(out_file)
          src.append(out_file)
      elif cmds[cmd.name].typ == CmdType.MANY_TO_ONE:
        l.append(f"build {cmds[cmd.name].out}: {cmd.name} {' '.join(inp_src)}")
        src.append(cmds[cmd.name].out)
        outs.append(cmds[cmd.name].out)
      elif cmds[cmd.name].typ == CmdType.ONE_TO_MANY:
        error("the 'one to many' command type is not implemented yet!")
      for k, v in cmd.vars.items():
        l.append(f"  {k} = {v}")
    
    l.append("")
    expt = [f for g in self.cfg.expt for f in glob.glob(g)]
    return Translation(
      lines = l,
      includes = includes,
      outputs = list(set(outs).intersection(expt))
    )

def parse_command_cfg(parser: configparser.ConfigParser, section: str) -> CmdCfg:
  return CmdCfg(
    typ = CMD_TYPE_STRING[parser.get(section, "typ").lower()],
    inp = parser.get(section, "inp"),
    out = parser.get(section, "out"),
    cmd = parser.get(section, "cmd"))

def parse_commands_cfg(parser: configparser.ConfigParser) -> CommandsCfgFile:
  return CommandsCfgFile({
    section: parse_command_cfg(parser, section)
    for section in parser.sections()
    if section != "DEFAULT"
  })

def parse_cmds(cmdstr: str) -> list[CmdInfo]:
  cmds: list[CmdInfo] = []
  state = ''
  vnstr, vvstr = '', ''
  for c in cmdstr:
    if c.isspace() and state != 'vv':
      if state == 'n': state = ''
      continue
    if state == 'vv':
      if c == ')':
        cmds[-1].vars[vnstr] = vvstr.strip()
        vnstr, vvstr = '', ''
        state = 'n'
      else: vvstr += c
    elif c.isalnum() or c == '_':
      if state == '':
        cmds.append(CmdInfo(name = c, vars = {}))
        state = 'n'
      elif state == 'n': cmds[-1].name += c
      elif state == 'vn': vnstr += c
    elif c == '=' and state == 'vn':
      state = 'vv'
    elif c == '(' and state == 'n':
      vnstr, vvstr = '', ''
      state = 'vn'
      
  return cmds

parse_vars_pattern = re.compile(r'\$(\{([\w_]+)\}|([\w_]+))')
def parse_vars(s: str) -> str:
  res = list(s)
  for match in re.finditer(parse_vars_pattern, s):
    res[match.start():match.end()] = match.group(1)
  return ''.join(res)

def parse_project_cfg(parser: configparser.ConfigParser) -> ProjectCfgFile:
  cfg = ProjectCfgFile(
    cfg = ProjectCfg(
      name = parser.get("cfg", "name"),
      desc = parser.get("cfg", "desc"),
      deps = parser.get("cfg", "deps", fallback="").split(),
      cmds = parse_cmds(parser.get("cfg", "cmds")),
      srcs = parser.get("cfg", "srcs").split(),
      expt = list(map(parse_vars, parser.get("cfg", "expt", fallback="").split())),
    ),
    vars = dict(parser.items("var")),
    includes = {}
  )

  if parser.has_section(get_platform_name()):
    cfg.vars.update(dict(parser.items(get_platform_name())))

  for include in parser.get("DEFAULT", "includes").split():
    v = parse_cfg(include)
    if v is None: continue
    cfg.includes[include] = v
  
  return cfg

def parse_cfg(file: str) -> Optional[CfgFile]:
  parser = configparser.ConfigParser(default_section=None) # type: ignore
  with open(file) as f:
    parser.read_string("[DEFAULT]\n" + f.read(), file)
  filetype = parser.get("DEFAULT", "type")
  if filetype == "commands":
    return parse_commands_cfg(parser)
  elif filetype == "project":
    return parse_project_cfg(parser)
  
  error(f"Unknown file type: {filetype}")

def project(name: str) -> list[tuple[bool, str]]:
  cfg = parse_cfg(f"{name}/project.cfg")
  assert cfg is not None
  translation = cfg.translate()
  save_ninja(f"{name}/project.cfg", translation.lines)
  return translation.includes

includes = project("tests")
with open("build.ninja", "w") as f:
  f.write(f"# generated by gen.py\n")

  already_included: set[str] = set()
  for (dep, path) in includes:
    if path in already_included: continue
    else: already_included.add(path)
    if not dep: f.write(f"include {path}\n")
    else: f.write(f"subninja {path}\n")
  f.write("subninja tests/project.cfg.ninja\n")

os.system("ninja -t compdb > compile_commands.json")
